---
const rtTypes = ["Conditions", "Effects", "Events", "Expressions", "Functions", "Sections", "Structures", "Types"]

import docs from "../../assets/docs/docs.json";

const latest = docs.skriptVersion.match(/\d+\.(\d+)/)!!;
const latestMinor = parseInt(latest[1], 10)!! - 1;

const versions = [];
for (let i = latestMinor + 1; i > latestMinor - 4; i--) {
    versions.push(`2.${i}`);
}

---

<script>

    enum _DocType {
        TYPE = "Type",
        CONDITION = "Condition",
        EFFECT = "Effect",
        EVENT = "Event",
        EXPRESSION = "Expression",
        FUNCTION = "Function",
        SECTION = "Section",
        STRUCTURE = "Structure"
    }

    const types: any = {
        "Types": _DocType.TYPE,
        "Conditions": _DocType.CONDITION,
        "Effects": _DocType.EFFECT,
        "Events": _DocType.EVENT,
        "Expressions": _DocType.EXPRESSION,
        "Functions": _DocType.FUNCTION,
        "Sections": _DocType.SECTION,
        "Structures": _DocType.STRUCTURE
    }

    /**
     * The things to filter on.
     */
    export interface Filter {
        types: string[];
        supported: string;
        changed: string;
    }

    /**
     * The current filter settings.
     */
    let filter: Filter = {
        types: [], 
        supported: "",
        changed: "",
    };

    /**
     * Deletes a query parameter from the URL.
     * @param key The key of the query parameter to delete.
     */
    function deleteParams(key: string) {
        const params = new URLSearchParams(window.location.search);
        params.delete(key);

        // if params is empty, remove ?
        if (params.toString() === "") {
            window.history.pushState({}, '', window.location.pathname);
            return;
        }

        const newUrl = window.location.pathname + '?' + params.toString();
        window.history.pushState({}, '', newUrl);
    }

    /**
     * Adds a query parameter to the URL.
     * @param key The key of the query parameter to add.
     * @param value The value of the query parameter to add.
     */
    function addParams(key: string, value: string) {
        const params = new URLSearchParams(window.location.search);
        params.set(key, value);
        const newUrl = window.location.pathname + '?' + params.toString();
        window.history.pushState({}, '', newUrl);
    }

    /**
     * Clears all query parameters from the URL.
     */
    function clearParams() {
        window.history.pushState({}, '', window.location.pathname);
    }

    /**
     * Applies the current filters found in the URL to the filter object.
     */
    function applyParams() {
        const params = new URLSearchParams(window.location.search);

        let types = params.get("types");
        if (types === null) {
            filter.types = [];
        } else {
            filter.types = decodeURIComponent(types).split(",") || [];
        }
        filter.supported = decodeURIComponent(params.get("supported") || "");
        filter.changed = decodeURIComponent(params.get("changed") || "");        
    }

    function toggle(array: Array<string>, value: string) {
        const index = array.indexOf(value);

        if (index === -1) {
            array.push(value);
        } else {
            array.splice(index, 1);
        }
    }

    /**
     * Handles a click event on a filter button.
     * @param button The button element that was clicked.
     */
    function handleClick(button: HTMLButtonElement) {
        const text = button.textContent!!.trim();
        const attribute = button.getAttribute("data-type")!!;

        // update filter variable
        switch (attribute) {
            case "type":
                toggle(filter.types, text);

                if (filter.types.length === 0) {
                    deleteParams("types");
                } else {
                    addParams("types", encodeURIComponent(filter.types.join(",")));
                }
                break;
            case "supported":
                if (text === filter.supported) {
                    filter.supported = "";
                    filter.changed = "";
    
                    deleteParams("supported");
                    deleteParams("changed");
                } else {
                    filter.supported = text;
                    filter.changed = "";

                    addParams("supported", encodeURIComponent(text));
                    deleteParams("changed");
                }
                break;
            case "changed":
                if (text === filter.changed) {
                    filter.changed = "";
                    filter.supported = "";
    
                    deleteParams("supported");
                    deleteParams("changed");
                } else {
                    filter.changed = text;
                    filter.supported = "";

                    deleteParams("supported");
                    addParams("changed", encodeURIComponent(text));
                }
                break;
            default:
                console.warn(`Unknown filter type: ${button.getAttribute("data-type")}`);
                return;
        }

        // update rest of buttons
        const buttons = document.querySelectorAll("#filters button");
        buttons.forEach(button => {
            let match = false;

            switch (button.getAttribute("data-type")) {
                case "type":
                    match = filter.types.includes(button.textContent!!.trim());
                    break;
                case "supported":
                    match = filter.supported === button.textContent!!.trim();
                    break;
                case "changed":
                    match = filter.changed === button.textContent!!.trim(); 
                    break;
                default:
                    return;
            }

            if (match) {
                button.classList.add("bg-skript", "text-white", "font-bold");
                button.classList.remove("bg-l-bg-secondary", "dark:bg-d-bg-secondary");
            } else {
                button.classList.add("bg-l-bg-secondary", "dark:bg-d-bg-secondary");
                button.classList.remove("bg-skript", "text-white", "font-bold");
            }
        });

        [...document.getElementById("docs")!!.children,
        ...document.getElementById("syntax")!!.children
        ].forEach(element => {
            if (element instanceof HTMLHeadingElement) {
                return;
            }

            element.classList.remove("hidden-by-type", "hidden-by-changed", "hidden-by-supported");

            checkType(element);
            checkSupported(element);
            checkSince(element);
        });
    }
    
    /**
     * Check if the element matches the current type filter.
     * @param element The element to check.
     */
    function checkType(element: Element) {
        if (filter.types.length === 0) {
            return;
        }

        for (const t of filter.types) {
            if (element.getAttribute("data-type")?.includes(types[t])) {
                return;
            }
        }

        element.classList.add("hidden-by-type");
    }

    /**
     * Check if the element matches the current supported filter.
     * @param element The element to check.
     */
    function checkSupported(element: Element) {
        if (filter.supported === "") {
            return;
        }

        const since1 = element.getAttribute("data-since");
        if (since1 === null) {
            return;
        }

        const minor1 = parseInt(filter.supported.match(/\d+\.(\d+)/)!![1], 10);
        since1.matchAll(/\d+\.(\d+)/g).forEach((match) => {
            const otherMinor = parseInt(match[1], 10);
        
            if (otherMinor > minor1) {
                element.classList.add("hidden-by-supported");
                return;
            }
        });
    }

    /**
     * Check if the element matches the current since filter.
     * @param element The element to check.
     */
    function checkSince(element: Element) {
        const since = element.getAttribute("data-since");
        if (since === null) {
            return;
        }

        if (!since.includes(filter.changed)) {
            element.classList.add("hidden-by-changed");
            return;
        }
    }

    /**
     * Reset all filter buttons to their default state.
     */
    function resetButtons() {
        const buttons = document.querySelectorAll("#filters .filter-button");
        buttons.forEach(button => {
            if (button.classList.contains("text-white")) {
                (button as HTMLButtonElement).click();
            }
        });
    }

    const expand = document.getElementById("filter-expand-button")!!;
    const expandIcon = document.getElementById("filter-expand-icon")!!;
    const filterElements = document.getElementById("filter-expand-area")!!;
    document.getElementById("filter-clear")!!.addEventListener("click", () => {
        // double fire eventts to avoid clear button opening the filter menu
        filterElements.classList.toggle("hidden");
        filterElements.classList.toggle("flex");
        expandIcon.querySelector("svg")!!.classList.toggle("rotate-90");
        resetButtons();
        clearParams();
    });

    expand.addEventListener("click", () => {
        filterElements.classList.toggle("hidden");
        filterElements.classList.toggle("flex");
        expandIcon.querySelector("svg")!!.classList.toggle("rotate-90");
    });

    if (screen.width > 768) {
        expand.click();
    }

    // === POSITIONS ===

    const filters = document.getElementById("filters")!!;
    function updatePosition() {
        // Update position of filters to be below the nav bar,
        // since filters is sticky this cant be done directly
        filters.style.top = `${document.getElementById("nav")!!.offsetHeight - 1}px`;   
    }

    updatePosition();

    window.addEventListener("DOMContentLoaded", () => {
        updatePosition();
        filters.classList.remove("fixed"); // fix layout shift on load
        filters.classList.add("sticky"); // fix layout shift on load
    });

    window.addEventListener("resize", updatePosition);

    // === ON LOAD ===

    window.addEventListener("DOMContentLoaded", () => {
        applyParams();
        
        const buttons = document.querySelectorAll("#filters .filter-button");
        buttons.forEach(button => {
            button.addEventListener("click", () => handleClick(button as HTMLButtonElement));
        });

        (buttons[1] as HTMLButtonElement).click();
        (buttons[1] as HTMLButtonElement).click();
    });
</script>

<div id="filters" class="fixed right-0 top-[35px] sm:top-[118px]
    w-full md:w-64 h-fit md:h-[87vh] flex flex-col p-4 gap-2 
    border-b-2 md:border-b-0 md:border-l-2 border-l-border dark:border-d-border
    bg-l-bg dark:bg-d-bg
    overflow-y-hidden">

    <div id="filter-expand-button" class="p-4 -m-4 flex flex-row gap-2 hover:cursor-pointer">
        <h2>Filter by</h2>
        <div class="flex-auto"></div>
        <button id="filter-clear" class="px-2 w-fit rounded-sm 
            hover:cursor-pointer hover:opacity-80 transition
            bg-l-bg-secondary dark:bg-d-bg-secondary">
            Clear
        </button>
        <button id="filter-expand-icon" class="block md:hidden px-2 w-fit rounded-sm 
            hover:cursor-pointer hover:opacity-80 transition">
            <svg class="transition rotate-90" width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
                <path d="M8.60627 10.8563L5.88752 8.1375C5.85002 8.1 5.82202 8.0595 5.80352 8.016C5.78502 7.9725 5.77552 7.9255 5.77502 7.875C5.77502 7.775 5.80952 7.6875 5.87852 7.6125C5.94752 7.5375 6.03802 7.5 6.15002 7.5H11.85C11.9625 7.5 12.0533 7.5375 12.1223 7.6125C12.1913 7.6875 12.2255 7.775 12.225 7.875C12.225 7.9 12.1875 7.9875 12.1125 8.1375L9.39377 10.8563C9.33127 10.9188 9.26877 10.9625 9.20627 10.9875C9.14377 11.0125 9.07502 11.025 9.00002 11.025C8.92502 11.025 8.85627 11.0125 8.79377 10.9875C8.73127 10.9625 8.66877 10.9188 8.60627 10.8563Z"/>
                </svg>
        </button>
    </div>
    <div id="filter-expand-area" class="hidden flex-col gap-2 transition">
        <h3>Syntax type</h3>
        
        <div class="w-fit flex flex-row flex-wrap gap-2">
            {rtTypes.map(x => 
                <button data-type="type" class="filter-button p-2 rounded-md 
                    bg-l-bg-secondary dark:bg-d-bg-secondary 
                    hover:cursor-pointer hover:opacity-80 transition">
                    {x}
                </button>
            )}
        </div>

        <h3>Syntax is supported in</h3>
        <div class="flex flex-wrap gap-2">
            {versions.map(x => 
                <button data-type="supported" class="filter-button p-2 rounded-md text-center 
                    bg-l-bg-secondary dark:bg-d-bg-secondary 
                    hover:cursor-pointer hover:opacity-80 transition">
                    {x}
                </button>
            )}
        </div>

        <h3>Syntax was changed in</h3>
        <div class="flex flex-wrap gap-2">
            {versions.map(x => 
                <button data-type="changed" class="filter-button p-2 rounded-md text-center 
                    bg-l-bg-secondary dark:bg-d-bg-secondary 
                    hover:cursor-pointer hover:opacity-80 transition">
                    {x}
                </button>
            )}
        </div>
    </div>
</div>