---
// SyntaxDisplayManager.astro - Handles the displaying of the SyntaxCards, including combined filtering, virtual scrolling, and jumping via sidebar 
// represent all syntax cards as virtual items and only display them when needed.
export interface VirtualItem {
    element: HTMLElement; // actual html element to show/hide
    syntaxName: string;   // display name of syntax
    syntaxType: string;   // type of syntax (for type filtering)
    syntaxId: string;     // id of syntax (for search filtering)
    sidebarElement: HTMLElement | null; // corresponding element in the sidebar 
    height: number;       // actual height of the html element
    originalIndex: number; // index to sort the items properly
}
---

<script>
    const ESTIMATED_ITEM_HEIGHT = 450;
    const OVERSCAN_COUNT = 3;

    // -------------------
    // Setup virtual items
    // -------------------
    import type { VirtualItem } from "./SyntaxDisplayManager.astro";

    // get all syntaxes, then map them into VirtualItems
    const syntaxes = document.getElementById('syntaxes') as HTMLElement;
    const allItems: VirtualItem[] = Array.from(syntaxes.children).map((element, index) => {
        // get info + measure height
        const syntaxId = element.getAttribute('syntax-id')!;
        const syntaxType = element.getAttribute('syntax-type')!;
        const syntaxName = element.getAttribute('syntax-name')!;
        const sidebarElement = document.getElementById(`sidebar-${syntaxId}`);
        const height = (element as HTMLElement).offsetHeight || ESTIMATED_ITEM_HEIGHT;
        
        return { 
            element: element as HTMLElement, 
            syntaxName,
            syntaxType, 
            syntaxId, 
            sidebarElement,
            height,
            originalIndex: index
        };
    });

    // create the wrapper/viewport elements to determine what's on screen
    const wrapper = document.getElementById("vs_wrapper");
    if (!wrapper)
        throw new Error("vs wrapper missing!");
    const viewport = document.getElementById("vs_viewport");
    if (!viewport)
        throw new Error("viewport missing!");


    // move all elements to viewport but hidden until we need them
    allItems.forEach((item, index) => {
        item.element.style.display = 'none';
        item.element.style.order = '0'; // For flexbox ordering
        viewport.appendChild(item.element);
    });
    
    // -----------------
    // Positioning stuff
    // -----------------

    let positions: number[] = [];
    let visibleRange = { start: 0, end: 0 };

    // function for determining the virtual positions of cards based on the item heights
    // creates a long list of start positions as offsets from the top (dynamic programming!)
    function calculatePositions(items: VirtualItem[]) {
        const pos = [0];
        for (let i = 0; i < items.length; i++) {
            pos.push(pos[i] + items[i].height);
        }
        return pos;
    }

    // simple binarySearch for findVisibleRange
    function binarySearch(arr: number[], target: number): number {
        let left = 0;
        let right = arr.length;
        
        while (left < right) {
            const pivot = Math.floor((left + right) / 2);
            if (arr[pivot] < target) {
                left = pivot + 1;
            } else {
                right = pivot;
            }
        }
        return left;
    }

    // determine which items of the currently filtered items should be visible based on the heights/viewport size
    function findVisibleRange(scrollTop: number, viewportHeight: number) {
        if (positions.length === 0) return { start: 0, end: 0 };
        
        const start = Math.max(0, binarySearch(positions, scrollTop) - OVERSCAN_COUNT);
        const end = Math.min(filteredItems.length, binarySearch(positions, scrollTop + viewportHeight) + OVERSCAN_COUNT);
        
        return { start, end };
    }

    // ---------------
    // Filtering stuff
    // ---------------

    // init filters
    let filteredItems: VirtualItem[] = [];

    let typeFilter = new Set<string>();
    let searchFilter: Set<string> | null = null;
    let currentSearchQuery: string = '';

    // get what VirtualItems should actually "exist" based on the filters
    function getFilteredItems(): VirtualItem[] {   
        // Type filter
        let filtered = typeFilter.size === 0 
            ? [...allItems]
            : allItems.filter(item => typeFilter.has(item.syntaxType));
        
        // search filter
        if (searchFilter !== null) {
            if (searchFilter.size === 0) {
                filtered = [];
            } else {
                const filter = searchFilter;
                filtered = filtered.filter(item => filter.has(item.syntaxId));
            }
        }

        // Sort by search relevance if searching, otherwise by original order
        if (currentSearchQuery && currentSearchQuery.trim()) {
            const searchLower = currentSearchQuery.toLowerCase();
            return filtered
                // assign scores
                .map(item => ({ 
                    item,
                    score: scoreSearchMatch(item, searchLower)
                }))
                // sort
                .sort((a, b) => {
                    if (b.score !== a.score) {
                        return b.score - a.score;
                    }
                    return a.item.originalIndex - b.item.originalIndex;
                })
                // get items in order
                .map(s => s.item);
        }
        
        // Default: sort by original alphabetical order
        return filtered.sort((a, b) => a.originalIndex - b.originalIndex);
    }

    // function for getting just the text nodes from an element, without any child text (avoids the badge text)
    // from stackoverflow
    function getTextNodeContent(parentElement: any): any {
        return [].reduce.call(parentElement.childNodes, function(a: any, b: any): any { return a + (b.nodeType === 3 ? b.textContent : ''); }, '');
    }

    // assign search match score based on where the match was found/what was matched
    function scoreSearchMatch(item: VirtualItem, searchLower: string): number {
        if (!searchLower) return 0;
        let score = 0;
        const element = item.element;
        
        const name = getTextNodeContent(element.querySelector('h3'))?.toLowerCase() || '';
        const description = element.querySelector('p')?.textContent?.toLowerCase() || '';
        const code = element.querySelector('code')?.textContent?.toLowerCase() || '';
        
        // Exact match in name = highest score
        if (name === searchLower) score += 1000;
        // Name starts with search
        else if (name.startsWith(searchLower)) score += 500;
        // Name contains search
        else if (name.includes(searchLower)) score += 100;
        
        // Description contains
        if (description.includes(searchLower)) score += 50;
        
        // Code examples contain
        if (code.includes(searchLower)) score += 25;
        
        // prefer shorter names (more specific matches)
        if (name.includes(searchLower)) {
            score += Math.max(0, 50 - name.length);
        }
        
        return score;
    }

    // -------------
    // Sidebar stuff
    // -------------

    const scrollableSidebar = document.querySelector('#starlight__sidebar');
    if (!scrollableSidebar)
        throw new Error("couldn't find sidebar!!!");

    let autoSyncEnabled = true;

    // tell the sidebar to rebuild with the current filtered items
    function updateSidebar() {
        const sidebarAPI = (window as any).__syntaxSidebar;
        if (!sidebarAPI) {
            console.warn('Sidebar API not available yet');
            return;
        }
        
        sidebarAPI.rebuild(filteredItems);
    }

    // keeps the sidebar synchronized to the user's position in the main elements
    function syncSidebarScroll() {
        if (!autoSyncEnabled || !filteredItems.length || wrapper == null) return;
        
        const sidebarAPI = (window as any).__syntaxSidebar;
        if (!sidebarAPI) {
            console.warn('Sidebar API not available yet');
            return;
        }

        const viewportTop = window.scrollY;
        const viewportCenter = viewportTop + (window.innerHeight / 2);
        
        let closestIndex = 0;
        let closestDistance = Infinity;
        
        // determine which item is currently centered in the screen
        for (let i = 0; i < filteredItems.length; i++) {
            const itemTop = wrapper.offsetTop + positions[i];
            const itemBottom = wrapper.offsetTop + positions[i + 1];
            const itemCenter = (itemTop + itemBottom) / 2;
            
            const distance = Math.abs(itemCenter - viewportCenter);
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestIndex = i;
            }
        }
        
        const middleItem = filteredItems[closestIndex];
        sidebarAPI.highlight(middleItem.syntaxId);
        sidebarAPI.scrollTo(middleItem.syntaxId);
    }

    // Listen for sidebar clicks
    window.addEventListener('sidebar-item-click', ((event: CustomEvent) => {
        const { syntaxId } = event.detail;
        
        autoSyncEnabled = false;
        
        const targetIndex = filteredItems.findIndex(item => item.syntaxId === syntaxId);
        if (targetIndex !== -1) {
            const targetY = wrapper.offsetTop + positions[targetIndex];
            window.scrollTo({ 
                top: targetY - 100,
                behavior: 'smooth' 
            });
            
            const sidebarAPI = (window as any).__syntaxSidebar;
            if (sidebarAPI) {
                sidebarAPI.highlight(syntaxId);
                sidebarAPI.scrollTo(syntaxId);
            }

            // avoids the snap-back of the sync scrolling conflicting w/ auto scroll
            setTimeout(() => {
                autoSyncEnabled = true;
                syncSidebarScroll();
            }, 700);
        }
    }) as EventListener);

    // --------------------
    // Main rendering stuff
    // --------------------

    // Make viewport a flex container
    viewport.style.display = 'flex';
    viewport.style.flexDirection = 'column';

    // Updates which items are visible and sets display attr accordingly
    function renderVisible() {
        if (!wrapper || !viewport) return;
        if (!filteredItems.length) {
            allItems.forEach(item => {
                item.element.style.display = 'none';
            });
            return;
        }
        
        const rect = wrapper.getBoundingClientRect();
        const scrollTop = Math.max(0, -rect.top);
        const viewportHeight = window.innerHeight;
        
        const newRange = findVisibleRange(scrollTop, viewportHeight);
        
        // only update if range has changed
        if (newRange.start === visibleRange.start && newRange.end === visibleRange.end) {
            return;
        }
        
        visibleRange = newRange;
        
        // Hide all items first
        allItems.forEach(item => {
            item.element.style.display = 'none';
        });
        
        // Show visible items and set their order
        for (let i = visibleRange.start; i < visibleRange.end; i++) {
            const item = filteredItems[i];
            item.element.style.display = '';
            item.element.style.order = i.toString(); // CSS flexbox order
        }
        
        // Update viewport position
        viewport.style.transform = `translateY(${positions[visibleRange.start]}px)`;

        // Sync sidebar scroll
        syncSidebarScroll();
    }

    // runs the full render loop, filtering, calc positions, update sidebar, renderVisible, etc
    // Should only need to be run after filtering updates since that changes what items 'exist'.
    function fullRender() {
        if (!wrapper || !viewport) return;
        // Get new filtered items
        filteredItems = getFilteredItems();
        positions = calculatePositions(filteredItems);
        
        const totalHeight = positions[positions.length - 1] || 0;
        wrapper.style.height = `${totalHeight}px`;
        
        // Reset visible range when filtering changes
        visibleRange = { start: -1, end: -1 };
        
        updateSidebar();
        renderVisible();
    }

    // Use RAF for smooth scrolling - claude addition
    let rafId: number | null = null;
    function scheduleScroll() {
        if (rafId !== null) return;
        rafId = requestAnimationFrame(() => {
            renderVisible();
            rafId = null;
        });
    }

    // ---------------------
    // Initialize everything
    // ---------------------

    fullRender();

    // scroll/resize listeners
    window.addEventListener('scroll', scheduleScroll, { passive: true });
    window.addEventListener('resize', fullRender, { passive: true });

    // Expose API for other components
    (window as any).__syntaxDisplayManager = {
        allItems,
        updateTypeFilter: (types: Set<string>) => {
            typeFilter = types;
            fullRender();
        },
        updateSearchFilter: (matchingIds: Set<string> | null, searchQuery: string = '') => {
            searchFilter = matchingIds;
            currentSearchQuery = searchQuery;
            fullRender();
        }
    };
</script>
