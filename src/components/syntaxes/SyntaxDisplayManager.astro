---
// SyntaxDisplayManager.astro - Handles the displaying of the SyntaxCards, including combined filtering, virtual scrolling, and jumping via sidebar 
// represent all syntax cards as virtual items and only display them when needed.
export interface VirtualItem {
    element: HTMLElement; // actual html element to show/hide
    syntaxName: string;   // display name of syntax
    syntaxType: string;   // type of syntax (for type filtering)
    syntaxId: string;     // id of syntax (for search filtering)
    sidebarElement: HTMLElement | null; // corresponding element in the sidebar 
    height: number;       // actual height of the html element
    originalIndex: number; // index to sort the items properly
}

export interface Version {
    major: number;
    minor: number;
    patch: number;
}

export interface VersionFilterData {
    versions: Version[];
    range: 'strict' | 'above' | 'below';
    type: 'any' | 'added' | 'changed';
}
---

<script>
    const ESTIMATED_ITEM_HEIGHT = 450;
    const OVERSCAN_COUNT = 3;

    // -------------------
    // Setup
    // -------------------
    import type { VirtualItem, Version, VersionFilterData } from "./SyntaxDisplayManager.astro";

    // obtain container references
    const wrapper = document.getElementById('syntaxes-wrapper')!;
    const viewport = document.getElementById('syntaxes-viewport')!;

    // map all syntaxes into VirtualItems
    const allItems: VirtualItem[] = Array.from(viewport.children).map((ele, index) => {
        const element = ele as HTMLElement;

        // get info + measure height
        const syntaxType = element.dataset.syntaxType!;
        const syntaxId = element.dataset.syntaxId!;
        const syntaxName = element.dataset.syntaxName!;
        const sidebarElement = document.getElementById(`sidebar-${syntaxId}`);
        // of course it doesn't include margin...
        const height = (element.getBoundingClientRect().height + parseFloat(window.getComputedStyle(element).marginBottom)) || ESTIMATED_ITEM_HEIGHT;

        return { 
            element: element,
            syntaxName,
            syntaxType,
            syntaxId,
            sidebarElement,
            height,
            originalIndex: index
        };
    });

    // -----------------
    // Positioning Logic
    // -----------------

    let positions: number[] = [];
    let visibleRange = { start: 0, end: 0 };

    // function for determining the virtual positions of cards based on the item heights
    // creates a long list of start positions as offsets from the top (dynamic programming!)
    function calculatePositions(items: VirtualItem[]) {
        const pos = [0];
        for (let i = 0; i < items.length; i++) {
            pos.push(pos[i] + items[i].height);
        }
        return pos;
    }

    // simple binarySearch for findVisibleRange
    function binarySearch(arr: number[], target: number): number {
        let left = 0;
        let right = arr.length;

        while (left < right) {
            const pivot = Math.floor((left + right) / 2);
            if (arr[pivot] < target) {
                left = pivot + 1;
            } else {
                right = pivot;
            }
        }
        return left;
    }

    // determine which items of the currently filtered items should be visible based on the heights/viewport size
    function findVisibleRange(scrollTop: number, viewportHeight: number) {
        if (positions.length === 0) {
            return { start: 0, end: 0 };
        }

        const start = Math.max(0, binarySearch(positions, scrollTop) - OVERSCAN_COUNT);
        const end = Math.min(filteredItems.length, binarySearch(positions, scrollTop + viewportHeight) + OVERSCAN_COUNT);

        return { start, end };
    }

    // ---------------
    // Filtering Logic
    // ---------------

    // init filters
    let filteredItems: VirtualItem[] = [];

    let typeFilter = new Set<string>();
    let versionFilter: VersionFilterData = {
        versions: [], range: 'strict', type: 'any',
    };
    let returnTypeFilter: string | null = null;

    let hasSearch = false;
    let searchCache: Map<string, number> = new Map<string, number>();

    // get what VirtualItems should actually "exist" based on the filters
    function getFilteredItems(): VirtualItem[] {
        // Type filter
        let filtered = typeFilter.size === 0 
            ? [...allItems]
            : allItems.filter(item => typeFilter.has(item.syntaxType));

        // Version filter
        if (versionFilter.versions.length > 0) {
            filtered = filtered.filter(item => {
                let since: string[] | undefined = item.element.dataset.syntaxSince?.split(",");
                if (!since) {
                    return false;
                }

                // process type
                if (versionFilter.type === 'added') { // only consider the first version
                    since = since.slice(0, 1);
                } else if (versionFilter.type === 'changed') { // ignore the first version
                    since = since.slice(1);
                }

                for (const desired of versionFilter.versions) {
                    for (const entry of since) {
                        const provided = parseVersion(entry);
                        if (provided === null) {
                            continue;
                        }
                        if (provided.patch === undefined) { // if patch is not specified, assume 0
                            provided.patch = 0;
                        }

                        const result = compareVersions(desired, provided);
                        // process range
                        if ((result === 0 && versionFilter.range !== 'strict')
                            || (result === 1 && versionFilter.range !== 'below')
                            || (result === -1 && versionFilter.range !== 'above')) {
                            continue;
                        }

                        return true;
                    }
                }
                return false;
            });
        }

        // return type filter
        if (returnTypeFilter) {
            const target = returnTypeFilter.toLowerCase();
            filtered = filtered.filter(item => {
                if (item.element.dataset.syntaxReturns) {
                    const candidate = (item.element.dataset.syntaxReturns as string).toLowerCase();
                    // todo: inheritance mapping?
                    return candidate.includes(target);
                }
                return false;
            })          
        }

        if (hasSearch) { // need to filter and sort based on search cache
            return filtered
                .filter(item => searchCache.has(item.syntaxId))
                .sort((a, b) => {
                    const aScore = searchCache.get(a.syntaxId)!;
                    const bScore = searchCache.get(b.syntaxId)!;
                    if (bScore !== aScore) {
                        return bScore - aScore;
                    }
                    return a.originalIndex - b.originalIndex;
                })
        }

        // Default: sort by original alphabetical order
        return filtered.sort((a, b) => a.originalIndex - b.originalIndex);
    }

    const versionPattern = /.*?(\d+)\.(\d+)(?:\.(\d+))?.*/i;
    export function parseVersion(version: string): Version | null {
        const matches = versionPattern.exec(version);
        if (!matches) {
            return null;
        }
        return {
            major: parseInt(matches[1]),
            minor: parseInt(matches[2]),
            patch: matches[3] !== undefined ? parseInt(matches[3]) : 0,
        }
    }

    /**
     * @return Whether <code>a</code> is less than, equal to, or greater than <code>b</code>.
     * Expressed as -1, 0, or 1 respectively.
     */
    function compareVersions(a: Version, b: Version) : number {
        if (a.major > b.major) {
            return 1;
        } else if (a.major < b.major) {
            return -1;
        } else if (a.minor > b.minor) {
            return 1;
        } else if (a.minor < b.minor) {
            return -1;
        } else if (a.patch > b.patch) {
            return 1;
        } else if (a.patch < b.patch) {
            return -1;
        }
        return 0;
    }

    function recomputeSearchCache(query: string): void {
        // invalidate cache
        searchCache.clear();

        // prepare query
        const queryLower = query.toLowerCase().trim();
        if (queryLower.length === 0) {
            hasSearch = false;
            return;
        }
        hasSearch = true;

        // filter for matches and store them
        allItems
            .map(item => ({
                item,
                score: scoreSearchMatch(item, queryLower)
            }))
            .filter(s => s.score !== 0)
            .forEach(s => searchCache.set(s.item.syntaxId, s.score))
    }

    // function to get content from a specific code card
    function getCodeFromSection(element: HTMLElement, sectionTitle: string): string {
        const codeCards = Array.from(element.querySelectorAll('.code-card'));

        // select by title
        const targetCard = codeCards.find(card => {
            const title = card.querySelector('.title');
            return title?.textContent?.trim() === sectionTitle;
        });
        if (!targetCard) {
            return '';
        }

        // get all code element textContents from within that card
        return Array.from(targetCard.querySelectorAll('code'))
            .map(code => code.textContent?.toLowerCase() || '')
            .join(' ');
    }

    // assign search match score based on where the match was found/what was matched
    function scoreSearchMatch(item: VirtualItem, searchLower: string): number {
        if (!searchLower) {
            return 0;
        }
        let score = 0;
        const element = item.element;

        // Weigh ID
        const id = item.syntaxId.toLowerCase();
        if (id === searchLower) { // Exact match on syntax ID, immediately return
            return Number.MAX_SAFE_INTEGER;
        }

        // Weigh Name
        const name = item.syntaxName.toLowerCase();
        if (name === searchLower) { // Exact match in name = highest score
            score += 1000;
        } else if (id.startsWith(searchLower) || name.startsWith(searchLower)) {
            score += 500;
        } else if (id.includes(searchLower) || name.includes(searchLower)) {
            score += 200;
            // prefer shorter names (more specific matches)
            score += Math.max(0, 50 - name.length);
        }

        // Weigh Keywords
        const keywords = element.dataset.syntaxKeywords?.split(',');
        if (keywords) {
            for (const keyword of keywords) {
                if (searchLower.includes(keyword.toLowerCase())) {
                    score += 100;
                }
            }
        }

        // Weigh Patterns
        const patterns = getCodeFromSection(element, 'Patterns');
        if (patterns.includes(searchLower)) {
            score += 100;
        }

        // Weigh Description
        const description = element.querySelector('p')?.textContent?.toLowerCase() || '';
        if (description.includes(searchLower)) {
            score += 50;
        }

        // Weigh Examples
        const examples = getCodeFromSection(element, 'Examples');
        if (examples.includes(searchLower)) {
            score += 25;
        }

        return score;
    }

    // -------------
    // Sidebar stuff
    // -------------

    let autoSyncEnabled = true;

    // tell the sidebar to rebuild with the current filtered items
    function updateSidebar() {
        const sidebarAPI = (window as any).__syntaxSidebar;
        if (!sidebarAPI) {
            console.warn('Sidebar API not available yet');
            return;
        }

        sidebarAPI.rebuild(filteredItems);
    }

    // keeps the sidebar synchronized to the user's position in the main elements
    function syncSidebarScroll() {
        if (!autoSyncEnabled || filteredItems.length === 0 || !wrapper) {
            return;
        }

        const sidebarAPI = (window as any).__syntaxSidebar;
        if (!sidebarAPI) {
            console.warn('Sidebar API not available yet');
            return;
        }

        // determine first element whose name is visible
        const viewportTop = window.scrollY;
        for (let i = 0; i < filteredItems.length; i++) {
            const itemTop = wrapper.offsetTop + positions[i];
            if (itemTop > viewportTop) {
                sidebarAPI.highlight(filteredItems[i].syntaxId);
                sidebarAPI.scrollTo(filteredItems[i].syntaxId);
                break; 
            }
        }
    }

    function scrollTo(syntaxId: string): void {
        const targetIndex = filteredItems.findIndex(item => item.syntaxId === syntaxId);
        if (targetIndex === -1) {
            // TODO this should be handled a better way...
            if (!syntaxId.startsWith("Func")) {
                return scrollTo(`Func${syntaxId}`);
            }
            return;
        }
        autoSyncEnabled = false;
        const targetY = wrapper.offsetTop + positions[targetIndex];
        window.scrollTo({
            top: targetY - 100,
            behavior: 'smooth'
        });
        const sidebarAPI = (window as any).__syntaxSidebar;
        if (sidebarAPI) {
            sidebarAPI.highlight(syntaxId);
            sidebarAPI.scrollTo(syntaxId);
        }
        setTimeout(() => {
            autoSyncEnabled = true;
        }, 1500);
    }

    // Listen for sidebar clicks
    window.addEventListener('sidebar-item-click', ((event: CustomEvent) => {
        const { syntaxId } = event.detail;
        window.location.hash = `#${syntaxId}`;
    }) as EventListener);
    window.addEventListener('hashchange', (event: HashChangeEvent) => {
        const syntaxId = new URL(event.newURL).hash.substring(1); // remove #
        scrollTo(syntaxId);
    });

    // --------------------
    // Main Rendering Logic
    // --------------------

    // Updates which items are visible and sets display attr accordingly
    function renderVisible() {
        if (!wrapper || !viewport) return;
        if (filteredItems.length === 0) {
            allItems.forEach(item => {
                item.element.style.display = 'none';
            });
            return;
        }

        const rect = wrapper.getBoundingClientRect();
        const scrollTop = Math.max(0, -rect.top);
        const viewportHeight = window.innerHeight;

        const newRange = findVisibleRange(scrollTop, viewportHeight);

        // only update if range has changed
        if (newRange.start === visibleRange.start && newRange.end === visibleRange.end) {
            // Sync sidebar scroll regardless
            syncSidebarScroll();
            return;
        }

        visibleRange = newRange;

        // Hide all items first
        allItems.forEach(item => {
            item.element.style.display = 'none';
        });

        // Show visible items and set their order
        for (let i = visibleRange.start; i < visibleRange.end; i++) {
            const item = filteredItems[i];
            item.element.style.display = '';
            item.element.style.order = i.toString(); // CSS flexbox order
        }

        // Update viewport position
        viewport.style.transform = `translateY(${positions[visibleRange.start]}px)`;

        // Sync sidebar scroll
        syncSidebarScroll();
    }

    const noResultsElement = document.getElementById('syntaxes-no-results')!;

    // runs the full render loop, filtering, calc positions, update sidebar, renderVisible, etc
    // Should only need to be run after filtering updates since that changes what items 'exist'.
    function fullRender() {
        if (!wrapper || !viewport) {
            return;
        }
        // Get new filtered items
        filteredItems = getFilteredItems();
        positions = calculatePositions(filteredItems);

        const totalHeight = positions[positions.length - 1] || 0;
        wrapper.style.height = `${totalHeight}px`;

        // Reset visible range when filtering changes
        visibleRange = { start: -1, end: -1 };

        updateSidebar();
        renderVisible();
        if (filteredItems.length === 0) {
            noResultsElement.style.display = '';
        } else {
            noResultsElement.style.display = 'none';
        }
        window.scrollTo({
            top: 0,
            behavior: 'smooth',
        })
    }

    // Use RAF for smooth scrolling - claude addition
    let rafId: number | null = null;
    function scheduleScroll() {
        if (rafId !== null) return;
        rafId = requestAnimationFrame(() => {
            renderVisible();
            rafId = null;
        });
    }

    // ---------------------
    // Syntax Card Dialog
    // ---------------------

    const cardDialog = document.getElementById('syntaxes-card-dialog') as HTMLDialogElement;
    const cardDialogFrame = document.getElementById('syntaxes-card-dialog-frame')!;

    document.getElementById('syntaxes-card-dialog-title')!.children[0].addEventListener('click', () => {
        cardDialog.close();
    });

    document.querySelectorAll("[data-card-dialog]").forEach(element => {
        element.addEventListener("click", () => {
            showSyntaxDialog((element as HTMLElement).dataset.cardDialog!);
        });
    });

    function showSyntaxDialog(syntaxId: string) {
        const cardElement = document.getElementById(`card-${syntaxId}`)!;
        const dialogCardElement = cardElement.cloneNode(true) as HTMLElement;
        dialogCardElement.id = '';
        dialogCardElement.style.display = '';
        dialogCardElement.style.margin = '0';
        cardDialogFrame.replaceChildren(dialogCardElement);
        cardDialog.showModal();
    }

    // ---------------------
    // Initialize everything
    // ---------------------

    fullRender();
    scrollTo(window.location.hash.substring(1));

    // scroll/resize listeners
    window.addEventListener('scroll', scheduleScroll, { passive: true });
    window.addEventListener('resize', fullRender, { passive: true });

    // Expose API for other components
    (window as any).__syntaxDisplayManager = {
        allItems,
        updateTypeFilter: (types: Set<string>) => {
            typeFilter = types;
            fullRender();
        },
        updateVersionFilter: (data: VersionFilterData, rawVersions: string[]) => {
            data.versions = rawVersions.map(version => parseVersion(version)!);
            versionFilter = data;
            fullRender();
        },
        updateReturnTypeFilter: (type: string) => {
            returnTypeFilter = type;
            fullRender();
        },
        updateSearchQuery: (searchQuery: string = '') => {
            recomputeSearchCache(searchQuery);
            fullRender();
        }
    };
</script>
